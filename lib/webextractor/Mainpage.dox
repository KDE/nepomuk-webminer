/** \namespace NepomukMetaDataExtractor::WebExtractor

\brief The WebExtractor namespace contains all classes relevant to meta data fetching via plugins from the web

Additional metadata can be found on various webpages. How the dta is presented t othe user depends on the website.
The classes in this namespace deal with a plugin based system to help processing these data and transform it into a unified form
that can be used by the Pipe classes.

The plugin system is realized by the ExtractorFactory that will create the right plugin for the extraction.
In most cases the plugins will be realized by the Kross framework as Python, Ruby or JavaScript. In the case one wants to add a c++ based plugin it simply has to subclass the WebExtractor interface.

The plugins that will be used are determined by either the @c url that will be fetched or a @c unique @c identifier for the plugin.

\section nepomuk_example Python plugin usage

This shows a very basic example how the movie data would be created and processed.

Important functions are:

@li info()
@li searchItems (QVariantMap)
@li extractItemFromUri(QUrl)

To interact with the calling c++ part you can use the following methods of the object @c WebExtractor

@li searchResults(QVariantList)
@li itemResults(QVariantMap)
@li log(QString)
@li error(QString)

\code
# Python example for imdb fetcher
def info():
    return dict( name = 'The Internet Movie Database',
                 icon = 'imdb.png',
                 identifier = 'imdbmovies',
                 urlregex = 'http://www.imdb.com/title/tt',
                 resource = 'movie',
                 description = 'some description',
                 author = 'Some Developer',
                 email = 'some@mail.com')

def searchItems( parameters ):
	# get the right search parameters
	title = parameters['title']

	# start search
	ia = IMDb()
	results = ia.search_movie(title)
	
	searchResults = []
	for item in results :
                detailString = str(item['kind']) + ', ' + str(item['year'])
                fullUrl = 'http://www.imdb.com/title/tt' + item.movieID
                entryDict = dict(
                                 title = item['title'],
                                 details = detailString,
                                 url = fullUrl
                                 )

                        searchResults.append(entryDict)
	
	# return the result dictionary
	WebExtractor.searchResults( searchResults )
	
def extractItemFromUri( url ):
	#load webpage and extract results


	result = dict(  title = movie['title'],
			year = movie['year'],
			director = directorString,
			writer = writerString,
			cast = castString,
			genres = ';'.join(movie['genres']),
			plot = ';'.join(movie['plot']),
			runtime = ';'.join(movie['runtimes']),
			countries = ';'.join(movie['countries'])
			)

	# return the dictionary containing the meta data
	WebExtractor.itemResults( result )
\endcode

You can also write plugins via Ruby or JavaScript or any other scriptlanguage where interpreters for Kross exist

\section nepomuk_example WebExtractor usage sample

\code
ExtractorFactory *ef = new ExtractorFactory;

WebExtractor *we = ef->createExtractor("imdb");
connect(we, SIGNAL(searchResults(QVariantList)), this, SLOT(selectSearchEntry(QVariantList)));
connect(we, SIGNAL(itemResults(QVariantMap)), this, SLOT(fetchedItemDetails(QVariantMap)));
connect(we, SIGNAL(log(QString)), this, SLOT(addProgressInfo(QString)));

QVariantMap searchParameters;
searchparameters.insert("title", "Some Fancy Movie");

we->search( searchParameters );
\endcode

In the corresponding slots you can process search search results any further or display them to the user for selection.

To extract data for a specific search result url yo ucan do the following

\code

QUrl url(searchresultUrl)

we->extractItem( url );
\endcode

*/ 
