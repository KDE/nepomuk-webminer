/*
 * This file is part of the Nepomuk KDE project.
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * See the file "COPYING" for the exact licensing terms.
 */

/*
 * This file has been generated by the Nepomuk Resource class generator.
 * DO NOT EDIT THIS FILE.
 * ANY CHANGES WILL BE LOST.
 */

#include <nepomuk2/variant.h>
#include <nepomuk2/resourcemanager.h>
#include "musicpiece.h"

#include "musicalbum.h"

#include <QtCore/QDateTime>
#include <QtCore/QDate>
#include <QtCore/QTime>


Nepomuk2::MusicPiece::MusicPiece()
  : Resource( QUrl(), QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#MusicPiece") )
{
}



Nepomuk2::MusicPiece::MusicPiece( const MusicPiece& res )
  : Resource( res )
{
}


Nepomuk2::MusicPiece::MusicPiece( const Nepomuk2::Resource& res )
  : Resource( res )
{
}


Nepomuk2::MusicPiece::MusicPiece( const QString& uri )
  : Resource( uri, QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#MusicPiece") )
{
}

Nepomuk2::MusicPiece::MusicPiece( const QUrl& uri )
  : Resource( uri, QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#MusicPiece") )
{
}

Nepomuk2::MusicPiece::MusicPiece( const QString& uri, const QUrl& type )
  : Resource( uri, type )
{
}


Nepomuk2::MusicPiece::MusicPiece( const QUrl& uri, const QUrl& type )
  : Resource( uri, type )
{
}

Nepomuk2::MusicPiece::~MusicPiece()
{
}

Nepomuk2::MusicPiece& Nepomuk2::MusicPiece::operator=( const MusicPiece& res )
{
    Resource::operator=( res );
    return *this;
}

QString Nepomuk2::MusicPiece::resourceTypeUri()
{
    return QLatin1String("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#MusicPiece");
}

QList<Nepomuk2::MusicAlbum> Nepomuk2::MusicPiece::musicAlbums() const
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    QList<MusicAlbum> rl;
    QList<Resource> l = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum") ).toResourceList() ;
    for( QList<Resource>::const_iterator it = l.constBegin();
        it != l.constEnd(); ++it )
    rl.append( MusicAlbum( *it ) );
    return rl;
}

void Nepomuk2::MusicPiece::setMusicAlbums( const QList<Nepomuk2::MusicAlbum>& value )
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    QList<Resource> l;
    for( QList<MusicAlbum>::const_iterator it = value.constBegin();
         it != value.constEnd(); ++it ) {
        l.append( Resource( (*it) ) );
    }
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum"), Variant( l ) );
}

void Nepomuk2::MusicPiece::addMusicAlbum( const Nepomuk2::MusicAlbum& value )
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum") );
    v.append( Resource( value ) );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum"), v );
}

Nepomuk2::MusicAlbum Nepomuk2::MusicPiece::musicAlbum() const
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    return MusicAlbum( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum") ).toResource().uri() );
}

void Nepomuk2::MusicPiece::setMusicAlbum( const Nepomuk2::MusicAlbum& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum"), Variant( value ) );
}

QUrl Nepomuk2::MusicPiece::musicAlbumUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicAlbum");
}

QList<qint64> Nepomuk2::MusicPiece::beatsPerMinutes() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#beatsPerMinute") ).toInt64List());
}

void Nepomuk2::MusicPiece::setBeatsPerMinutes( const QList<qint64>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#beatsPerMinute"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addBeatsPerMinute( const qint64& value )
{
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#beatsPerMinute") );
    v.append( value );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#beatsPerMinute"), v );
}

QUrl Nepomuk2::MusicPiece::beatsPerMinuteUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#beatsPerMinute");
}

QList<Nepomuk2::Resource> Nepomuk2::MusicPiece::performers() const
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    QList<Resource> rl;
    QList<Resource> l = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#performer") ).toResourceList() ;
    for( QList<Resource>::const_iterator it = l.constBegin();
        it != l.constEnd(); ++it )
    rl.append( Resource( *it ) );
    return rl;
}

void Nepomuk2::MusicPiece::setPerformers( const QList<Nepomuk2::Resource>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#performer"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addPerformer( const Nepomuk2::Resource& value )
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#performer") );
    v.append( Resource( value ) );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#performer"), v );
}

QUrl Nepomuk2::MusicPiece::performerUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#performer");
}

QList<Nepomuk2::Resource> Nepomuk2::MusicPiece::composers() const
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    QList<Resource> rl;
    QList<Resource> l = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#composer") ).toResourceList() ;
    for( QList<Resource>::const_iterator it = l.constBegin();
        it != l.constEnd(); ++it )
    rl.append( Resource( *it ) );
    return rl;
}

void Nepomuk2::MusicPiece::setComposers( const QList<Nepomuk2::Resource>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#composer"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addComposer( const Nepomuk2::Resource& value )
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#composer") );
    v.append( Resource( value ) );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#composer"), v );
}

QUrl Nepomuk2::MusicPiece::composerUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#composer");
}

QList<Nepomuk2::Resource> Nepomuk2::MusicPiece::lyricists() const
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    QList<Resource> rl;
    QList<Resource> l = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#lyricist") ).toResourceList() ;
    for( QList<Resource>::const_iterator it = l.constBegin();
        it != l.constEnd(); ++it )
    rl.append( Resource( *it ) );
    return rl;
}

void Nepomuk2::MusicPiece::setLyricists( const QList<Nepomuk2::Resource>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#lyricist"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addLyricist( const Nepomuk2::Resource& value )
{
    // We always store all Resource types as plain Resource objects.
    // It does not introduce any overhead (due to the implicit sharing of
    // the data and has the advantage that we can mix setProperty calls
    // with the special Resource subclass methods.
    // More importantly Resource loads the data as Resource objects anyway.
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#lyricist") );
    v.append( Resource( value ) );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#lyricist"), v );
}

QUrl Nepomuk2::MusicPiece::lyricistUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#lyricist");
}

QList<qint64> Nepomuk2::MusicPiece::trackNumbers() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber") ).toInt64List());
}

void Nepomuk2::MusicPiece::setTrackNumbers( const QList<qint64>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addTrackNumber( const qint64& value )
{
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber") );
    v.append( value );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber"), v );
}

qint64 Nepomuk2::MusicPiece::trackNumber() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber") ).toInt64List() << 0 ).first();
}

void Nepomuk2::MusicPiece::setTrackNumber( const qint64& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber"), Variant( value ) );
}

QUrl Nepomuk2::MusicPiece::trackNumberUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackNumber");
}

QList<qint64> Nepomuk2::MusicPiece::musicBrainzTrackIDs() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID") ).toInt64List());
}

void Nepomuk2::MusicPiece::setMusicBrainzTrackIDs( const QList<qint64>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addMusicBrainzTrackID( const qint64& value )
{
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID") );
    v.append( value );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID"), v );
}

qint64 Nepomuk2::MusicPiece::musicBrainzTrackID() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID") ).toInt64List() << 0 ).first();
}

void Nepomuk2::MusicPiece::setMusicBrainzTrackID( const qint64& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID"), Variant( value ) );
}

QUrl Nepomuk2::MusicPiece::musicBrainzTrackIDUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#musicBrainzTrackID");
}

QList<double> Nepomuk2::MusicPiece::trackGains() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain") ).toDoubleList());
}

void Nepomuk2::MusicPiece::setTrackGains( const QList<double>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addTrackGain( const double& value )
{
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain") );
    v.append( value );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain"), v );
}

double Nepomuk2::MusicPiece::trackGain() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain") ).toDoubleList() << 0.0 ).first();
}

void Nepomuk2::MusicPiece::setTrackGain( const double& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain"), Variant( value ) );
}

QUrl Nepomuk2::MusicPiece::trackGainUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackGain");
}

QList<double> Nepomuk2::MusicPiece::trackPeakGains() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain") ).toDoubleList());
}

void Nepomuk2::MusicPiece::setTrackPeakGains( const QList<double>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addTrackPeakGain( const double& value )
{
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain") );
    v.append( value );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain"), v );
}

double Nepomuk2::MusicPiece::trackPeakGain() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain") ).toDoubleList() << 0.0 ).first();
}

void Nepomuk2::MusicPiece::setTrackPeakGain( const double& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain"), Variant( value ) );
}

QUrl Nepomuk2::MusicPiece::trackPeakGainUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#trackPeakGain");
}

QList<qint64> Nepomuk2::MusicPiece::setNumbers() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber") ).toInt64List());
}

void Nepomuk2::MusicPiece::setSetNumbers( const QList<qint64>& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber"), Variant( value ) );
}

void Nepomuk2::MusicPiece::addSetNumber( const qint64& value )
{
    Variant v = property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber") );
    v.append( value );
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber"), v );
}

qint64 Nepomuk2::MusicPiece::setNumber() const
{
    return ( property( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber") ).toInt64List() << 0 ).first();
}

void Nepomuk2::MusicPiece::setSetNumber( const qint64& value )
{
    setProperty( QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber"), Variant( value ) );
}

QUrl Nepomuk2::MusicPiece::setNumberUri()
{
    return QUrl::fromEncoded("http://www.semanticdesktop.org/ontologies/2009/02/19/nmm#setNumber");
}


